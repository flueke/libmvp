/* Utilitiues to recover ZIP archives generated by mvme that got corrupted due to
 * a crash or power outage or similar.
 *
 * Based on BruteZip by Jason A. Donenfeld, https://git.zx2c4.com/BruteZip/about/
 */

#include "listfile_recovery.h"
#include <QtEndian>
#include <system_error>
#include <zlib.h>
#include <mesytec-mvlc/mvlc_listfile_zip.h>
#include <mesytec-mvlc/util/logging.h>

namespace
{

typedef struct
{
	uint32_t sig __attribute__ ((packed));
	uint16_t version __attribute__ ((packed));
	uint16_t gen __attribute__ ((packed));
	uint16_t compression __attribute__ ((packed));
	uint16_t modtime __attribute__ ((packed));
	uint16_t moddate __attribute__ ((packed));
	uint32_t crc32 __attribute__ ((packed));
	uint32_t compressedsize __attribute__ ((packed));
	uint32_t uncompressedsize __attribute__ ((packed));
	uint16_t filenamelength __attribute__ ((packed));
	uint16_t extrafieldlength __attribute__ ((packed));
} lfh;

inline std::system_error make_errno_exception(const char *what)
{
	return std::system_error(errno, std::generic_category(), what);
}

}

namespace mesytec::mvme::listfile_recovery
{

EntryFindResult
    find_first_entry(const std::string &zipFilename)
{
	EntryFindResult result = {};

	FILE *fh = fopen(zipFilename.c_str(), "rb");

	if (!fh)
		throw make_errno_exception("opening input file");

	while (!feof(fh))
	{
		uint32_t sig = 0;

		if (fread(&sig, sizeof(sig), 1, fh) == 0)
		{
			fclose(fh);
			throw make_errno_exception("reading local file header signature");
		}

		if (sig == 0x04034b50)
		{
			fseek(fh, -sizeof(sig), SEEK_CUR);
			result.headerOffset = ftell(fh);

			lfh header = {};
			char filename[UINT16_MAX];

			if (fread(&header, sizeof(header), 1, fh) == 0)
			{
				fclose(fh);
				throw make_errno_exception("reading local file header");
			}

			if (fread(filename, sizeof(char), header.filenamelength, fh) < header.filenamelength)
			{
				fclose(fh);
				throw make_errno_exception("reading local file header filename");
			}

			filename[header.filenamelength] = '\0';

			fseek(fh, header.extrafieldlength, SEEK_CUR);

			result.dataStartOffset = ftell(fh);
			result.compressionType = header.compression;
			result.entryName = filename;
			break;
		}
	}

	fclose(fh);
	return result;
}

RecoveryProgress
    recover_listfile(
        const std::string &inputFilename,
        const std::string &outputFilename,
        const EntryFindResult &entryInfo,
        mesytec::mvlc::Protected<RecoveryProgress> &progress_)
{
	// open input file
	// seek to dataStartOffset in the input file
	// open output file
	// create zip archive entry
	// decide how to init the output stream based on the compressionTyype
	// while input file has data left
	// 		inflate/read from the input stream into a buffer
	//		deflate/write the buffer to the output stream

    using namespace mesytec::mvlc;
	auto logger = mesytec::mvlc::get_logger("listfile_recovery");
	RecoveryProgress progress = {};
	FILE *inputFile = nullptr;
	z_stream strm = {};

	try
	{
		inputFile = fopen(inputFilename.c_str(), "rb");

		if (!inputFile)
			throw make_errno_exception("opening input file");

		if (fseek(inputFile, 0, SEEK_END) != 0)
			throw make_errno_exception("determining input file size (fseek)");

		if (auto pos = ftell(inputFile); pos < 0)
			throw make_errno_exception("determining input file size (ftell)");
		else
			progress.inputFileSize = static_cast<size_t>(pos);

		if (fseek(inputFile, entryInfo.dataStartOffset, SEEK_SET) != 0)
			throw make_errno_exception("seeking to data start offset in the input file");

		progress.inputBytesRead += entryInfo.dataStartOffset;
		progress_.access().ref() = progress;

        listfile::ZipCreator zipCreator;
        zipCreator.createArchive(outputFilename, listfile::OverwriteMode::Overwrite);
        auto writeHandle = zipCreator.createZIPEntry(
            entryInfo.entryName,
            entryInfo.compressionType == Z_DEFLATED ? 1 : 0); // compression level

		inflateInit2(&strm, -MAX_WBITS);
		std::array<u8, 0x10000> buffer;
		std::array<u8, 0x10000> zbuffer;

        while (!feof(inputFile))
        {
            auto len = fread(buffer.data(), 1, buffer.size(), inputFile);
			progress.inputBytesRead += len;

            if (entryInfo.compressionType == Z_DEFLATED)
            {
                strm.avail_in = len;
                strm.next_in = buffer.data();
                do
                {
                    strm.avail_out = zbuffer.size();
                    strm.next_out = zbuffer.data();

                    auto res = inflate(&strm, Z_SYNC_FLUSH);

                    if (res != Z_OK && res != Z_STREAM_END && res != Z_BUF_ERROR)
                        throw std::runtime_error(fmt::format("inflate() failed (zlib error {})", res));

                    len = zbuffer.size() - strm.avail_out;
                    writeHandle->write(zbuffer.data(), len);

					progress.outputBytesWritten += len;
                } while (strm.avail_out == 0);
            }
            else
            {
                writeHandle->write(buffer.data(), len);
				progress.outputBytesWritten += len;
            }

			progress_.access().ref() = progress;

        }

		inflateEnd(&strm);
		fclose(inputFile);
		inputFile = nullptr;
    }
	catch(const std::exception &e)
	{
		logger->error("exception caught: '{}', rethrowing", e.what());
		inflateEnd(&strm);
		if (inputFile)
			fclose(inputFile);
		throw;
	}

	return progress;
}

} // namespace mesytec::mvme::listfile_recovery